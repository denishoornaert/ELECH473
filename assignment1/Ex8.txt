	// nop x 8
	movi 3, 0x0003
	movi 4, 0x0004
	movi 5, 0x0005
	movi 6, 0x0006
	
	// start memory address
	movi 1, 0x0001
	
	// Save Reg4 and Reg6 in memory
	sw 4, 1, 0
	sw 6, 1, 1
	movi 4, 0x0000
	movi 6, 0x0000
	
	// Add first 15 bits
	movi 2, 0x7fff  // Mask
	nand 4, 3, 2    // Isolate 15 bits
	nand 4, 4, 4    // Reverse to and
	nand 6, 5, 2    // Isolate 15 bits
	nand 6, 6, 6    // Reverse to and
	
	add 7, 4, 6 // add Reg3 and Reg5 in Reg1
	sw 7, 1, 2  // save result in memory

	// MSB of Reg3 and Reg5
	movi 2, 0x8000  // Mask
	nand 4, 3, 2    // Isolate 1 bit
	nand 4, 4, 4    // Reverse to and
	nand 6, 5, 2	// Isolate 1 bit
	nand 6, 6, 6	// Reverse to and
	sw 4, 1, 3	// Save word in 3
	sw 6, 1, 4	// Save word in 4
	
	// MSB of Reg3+Reg4
	lw 4, 1, 2	// Load res add 15 bits
	nand 7, 4, 2	// Get the MSB of A+B
	nand 7, 7, 7	// Reverse

	// Now we have : 
	// 	REG1 : Memory start
	//	REG2 : Mask 0x8000
	//	REG3 : LSB of val1
	//	REG4 : add 15B + 15B
	//	REG5 : LSB of val2
	//	REG6 : MSB bit of REG5
	//	REG7 : MSB of REG3+REG5

	// Condition
test_one: nop
	beq 4, 2, one_rone	// If
	movi 4, 0x0000		// Else
	movi 1, ADDR "test_two" // test_two addr
	jalr 1, 1		// Jump

one_rone: nop 
	movi 4, 0x0001

test_two: nop
	beq 6, 2, one_rtwo	// If
	movi 6, 0x0000		// Else
	movi 1, ADDR "test_sum" // test_sum addr
	jalr 1, 1		// Jump

one_two: nop
	movi 6, 0x0001

test_sum: nop
	beq 7, 2, one_rsum	// If
	movi 7, 0x0000		// Else
	movi 1, ADDR "sec_part" // sec_part addr
	jalr 1,1		// jump

one_sum: nop
	movi 7, 0x0001

sec_part: nop
	add 4, 4, 6
	add 4, 4, 7

	movi 2, 0x0002
	nand 4, 4, 2
	movi 2, 0xfffd
	beq 5, 4, car_addr
	movi 2, 0x0000
	movi 1, ADDR "aft_carr" // aft_carr addr
	jalr 1, 1

car_addr; nop
	movi 2, 0x0001

aft_carr: nop
	add 3, 3, 5

msb_part:
	movi 1, 0x0001
	lw 4, 1, 0
	lw 5, 1, 1
	add 4, 4, 5
	add 4, 4, 2

	halt 
	
	// nop x 8
	movi 3, 0x0003
	movi 4, 0x0004
	movi 5, 0x0005
	movi 6, 0x0006

	// start memory address
	movi 1, 0x0001

	// Save Reg4 and Reg6 in memory
	sw 4, 1, 0
	sw 6, 1, 1
	movi 4, 0x0000
	movi 6, 0x0000

	// Add first 15 bits
	movi 2, 0x7fff  // Mask
	nand 4, 3, 2    // Isolate 15 bits
	nand 4, 4, 4    // Reverse to and
	nand 6, 5, 2    // Isolate 15 bits
	nand 6, 6, 6    // Reverse to and

	add 7, 4, 6 // add Reg3 and Reg5 in Reg1
	sw 7, 1, 2  // save result in memory

	// MSB of Reg3 and Reg5
	movi 2, 0x8000  // Mask
	nand 4, 3, 2    // Isolate 1 bit
	nand 4, 4, 4    // Reverse to and
	nand 6, 5, 2	// Isolate 1 bit
	nand 6, 6, 6	// Reverse to and
	sw 4, 1, 3	// Save word in 3
	sw 6, 1, 4	// Save word in 4

	// MSB of Reg3+Reg4
	lw 4, 1, 2	// Load res add 15 bits
	nand 7, 4, 2	// Get the MSB of A+B
	nand 7, 7, 7	// Reverse

	// Now we have :
	// 	REG1 : Memory start
	//	REG2 : Mask 0x8000
	//	REG3 : LSB of val1
	//	REG4 : add 15B + 15B
	//	REG5 : LSB of val2
	//	REG6 : MSB bit of REG5
	//	REG7 : MSB of REG3+REG5

	// Condition
test_one: nop
	beq 4, 2, one_rone	// If
	movi 4, 0x0000		// Else
	movi 1, 0x002d 	// test_two addr
	jalr 1, 1		// Jump

one_rone: nop
	movi 4, 0x0001

test_two: nop
	beq 6, 2, one_two	// If
	movi 6, 0x0000		// Else
	movi 1, 0x0037 // test_sum addr
	jalr 1, 1		// Jump

one_two: nop
	movi 6, 0x0001

test_sum: nop
	beq 7, 2, one_sum	// If
	movi 7, 0x0000		// Else
	movi 1, 0x0041 // sec_part addr
	jalr 1,1		// jump

one_sum: nop
	movi 7, 0x0001

sec_part: nop
	add 4, 4, 6
	add 4, 4, 7

	movi 2, 0x0002
	nand 4, 4, 2
	movi 2, 0xfffd
	beq 5, 4, car_addr
	movi 2, 0x0000
	movi 1, 0x0052 // aft_carr addr
	jalr 1, 1

car_addr: nop
	movi 2, 0x0001

aft_carr: nop
	add 3, 3, 5

msb_part: nop
	movi 1, 0x0001
	lw 4, 1, 0
	lw 5, 1, 1
	add 4, 4, 5
	add 4, 4, 2

	halt

# VERSION 1. Hypothesis : bak is accesible.

		mov in.b, bak		# acc = _, bak = b
		mov in.a, acc		# acc = a, bak = b
		mov acc, stack		# acc = a, bak = b, stack = a
start:		sub bak			# acc = a', bak = b, stack = a where a' = a-b
		jlz lz			# acc < 0 <=> a < b
		jez ez			# acc = 0 <=> a = b
ge:		mov acc, stack		# acc > 0 <=> a > b; acc = a', bak = b & stack = a' where a' = a-b
		jmp start
lz:		mov stack, acc		# acc = a, bak = b, stack = _
		mov acc, stack		# acc = a, bak = b, stack = a
		swp			# acc = b, bak = a, stack = a
		sub bak			# acc = b', bak = a, stack = a where b' = b-a
		swp			# acc = a, bak = b', stack = a where b' = b-a
		jmp start
ez:		mov a, down

# VERSION 2. Hypothesis : same as version 2 but bak is not accesible anymore.

		mov in.b, acc		# acc = b, bak = _
		sav			# acc = _, bak = b
		mov in.a, acc		# acc = a, bak = b
		mov acc, stack		# acc = a, bak = b, stack = a
start:		swp			# acc = b, bak = a, stack = a
		mov acc, stack		# acc = b, bak = a, stack = ba
		swp			# acc = a, bak = b, stack = ba
		sub stack		# acc = a', bak = b, stack = a where a' = a-b
		jlz lz			# acc < 0 <=> a < b
		jez ez			# acc = 0 <=> a = b
ge:		mov acc, stack		# acc > 0 <=> a > b; acc = a', bak = b & stack = a' where a' = a-b
		jmp start
lz:		mov stack, acc		# acc = a, bak = b, stack = _
		mov acc, stack		# acc = a, bak = b, stack = a
		mov acc, stack		# acc = a, bak = b, stack = aa
		swp			# acc = b, bak = a, stack = aa
		sub stack		# acc = b', bak = a, stack = a where b' = b-a
		swp			# acc = a, bak = b', stack = a where b' = b-a
		jmp start
ez:		mov acc, down

# VERSION 3. Hypothesis : same as version 2 + test on 'b-a' instead of 'a-b' + neg of precomputed difference

		mov in.b, acc		# acc = b, bak = _
		mov acc, stack		# acc = b, bak = _, stack = b
		sav			# acc = b, bak = b, stack = b
		mov in.a, acc		# acc = a, bak = b, stack = b
		swp			# acc = b, bak = a, stack = b

		mov in.a, acc		# acc = a, bak = _, stack = _
		sav			# acc = a, bak = a, stack = _
		mov acc, stack		# acc = a, bak = a, stack = a
		mov in.b, acc		# acc = b, bak = a, stack = a

start:		mov acc, stack		# acc = b, bak = a, stack = ba
		sub stack		# acc = b', bak = a, stack = b where b' = b-a
		jlz lz			# acc < 0 <=> a > b
		jez ez			# acc = 0 <=> a = b
ge:		jmp start		# acc > 0 <=> a < b
lz:		neg acc			# acc = a', bak = a, stack = b where a' = -b' = -(b-a) = a-b
		swp			# acc = a, bak = a', stack = b where a' = -b' = -(b-a) = a-b
		mov stack, acc		# acc = b, bak = a', stack = _ where a' = -b' = -(b-a) = a-b
		mov acc, stack		# acc = b, bak = a', stack = b where a' = -b' = -(b-a) = a-b
		jmp start
ez:		mov acc, down		# return acc

# VERSION 4. Hypothesis : same as version 3 + switch order of arrival between in.a and in.b

			mov in.b, acc		# 			acc = b, bak = _, stack = _
			mov acc, stack		# 			acc = b, bak = _, stack = b
			sav					# 			acc = b, bak = b, stack = b
			mov in.a, acc		# 			acc = a, bak = b, stack = b
AccToStkX2:	mov acc, stack		# 			acc = a, bak = b, stack = ab
AccToStkX1:	mov acc, stack		# 			acc = a, bak = b, stack = aab
			swp					# 			acc = b, bak = a, stack = aab
			sub stack			# 			acc = b', bak = a, stack = ab where b' = b-a
			jlz lz				# acc < 0 <=> a > b
			jez ez				# acc = 0 <=> a = b
ge:			swp					# acc > 0 <=> a < b; 	acc = a, bak = b', stack = ab where b' = b-a
			jmp AccToStkX1
lz:			mov stack, nil		#			acc = b', bak = a, stack = b where b' = b-a
			neg acc				# 			acc = a', bak = a, stack = b where a' = -b' = -(b-a) = a-b
			swp					# 			acc = a, bak = a', stack = b where a' = -b' = -(b-a) = a-b
			mov stack, acc		# 			acc = b, bak = a', stack = _ where a' = -b' = -(b-a) = a-b
			mov acc, stack		# 			acc = b, bak = a', stack = b where a' = -b' = -(b-a) = a-b
			swp					# 			acc = a', bak = b, stack = b where a' = -b' = -(b-a) = a-b
			jmp AccToStkX2
ez:			mov acc, down		# return acc

# VERSION 5. Hypothesis : same as version 3 + switch order of arrival between in.a and in.b

			mov in.b, acc		# 			acc = b, bak = _, stack = _
			mov acc, stack		# 			acc = b, bak = _, stack = b
			sav					# 			acc = b, bak = b, stack = b
			mov in.a, acc		# 			acc = a, bak = b, stack = b
AccToStkX1:	swp					#			acc = b, bak = a, stack = b
			mov acc, stack		# 			acc = a, bak = b, stack = ab
			swp					# 			acc = b, bak = a, stack = ab
			sub stack			# 			acc = b', bak = a, stack = b where b' = b-a
			jlz lz				# acc < 0 <=> a > b
			jez ez				# acc = 0 <=> a = b
ge:			jmp AccToStkX1
lz:			neg acc				# 			acc = a', bak = a, stack = b where a' = -b' = -(b-a) = a-b
			swp					# 			acc = a, bak = a', stack = b where a' = -b' = -(b-a) = a-b
			mov stack, acc		# 			acc = b, bak = a', stack = _ where a' = -b' = -(b-a) = a-b
			mov acc, stack		# 			acc = b, bak = a', stack = b where a' = -b' = -(b-a) = a-b
			jmp AccToStkX1
ez:			mov acc, down		# return acc

# VERSION 6. Hypothesis : same as version 3 + switch order of arrival between in.a and in.b

			mov in.b, acc		# 			acc = b, bak = _, stack = _
			mov acc, stack		# 			acc = b, bak = _, stack = b
			sav					# 			acc = b, bak = b, stack = b
			mov in.a, acc		# 			acc = a, bak = b, stack = b
AccToStkX1:	swp					#			acc = b, bak = a, stack = b
			mov acc, stack		# 			acc = a, bak = b, stack = ab
			swp					# 			acc = b, bak = a, stack = ab
			sub stack			# 			acc = b', bak = a, stack = b where b' = b-a
			jez ez				# acc = 0 <=> a = b
			jgz gz				# acc > 0 <=> a < b
lz:			neg acc				# 			acc = a', bak = a, stack = b where a' = -b' = -(b-a) = a-b
			swp					# 			acc = a, bak = a', stack = b where a' = -b' = -(b-a) = a-b
			mov stack, acc		# 			acc = b, bak = a', stack = _ where a' = -b' = -(b-a) = a-b
			mov acc, stack		# 			acc = b, bak = a', stack = b where a' = -b' = -(b-a) = a-b
gz:			jmp AccToStkX1
ez:			mov acc, down		# return acc
